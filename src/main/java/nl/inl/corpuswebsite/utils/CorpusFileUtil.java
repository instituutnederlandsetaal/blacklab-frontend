package nl.inl.corpuswebsite.utils;

import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Optional;
import java.util.logging.Logger;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.TransformerException;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;

import nl.inl.corpuswebsite.MainServlet;
import nl.inl.corpuswebsite.utils.GlobalConfig.Keys;

public class CorpusFileUtil {
    private static final Logger logger = Logger.getLogger(CorpusFileUtil.class.getName());

    /**
     * Get a file from the directory belonging to this corpus and return it, attempting to get a default if that fails.
     * User corpora never have their own directory, and so will only use the locations for the defaults.
     *
     * <pre>
     * Tries in several locations:
     * - First try PROP_DATA_PATH/corpus/ directory (if configured, and this is not a user corpus)
     * - Then try PROP_DATA_PATH/PROP_DATA_DEFAULT directory (if configured)
     * - Finally try WEB-INF/interface-default
     * </pre>
     *
     * @param filesDir - the root dir where per-corpus files are stored (so not already resolved to the corpus name)
     *                      (i.e. {@link nl.inl.corpuswebsite.utils.GlobalConfig.Keys#CORPUS_CONFIG_DIR })
     * @param corpus - corpus for which to get the file. If null or a user-defined corpus only the default locations are
     *         checked.
     * @param fallbackCorpus - for when the corpus does not exist, try this one instead (i.e. {@link nl.inl.corpuswebsite.utils.GlobalConfig.Keys#DEFAULT_CORPUS_CONFIG}).
     * @param filePath - path to the file relative to the directory for the corpus.
     * @return the file, if found
     */
    public static Optional<File> getProjectFile(String filesDir, Optional<String> corpus, Optional<String> fallbackCorpus, Optional<String> filePath) {
        Optional<Path> dataDir = getIfValid(filesDir);
        return dataDir
            // try the file in the corpus' own data directory,
            // (only when a valid non-user corpus)
            // (we don't support configuring user corpora)
            // There's no reason that couldn't work, but since users can't upload the files to do so anyway,
            // configure it, it's not worth the effort (and there might be a few gotchas with username to file path mapping).
            .filter(path -> !isUserCorpus(corpus))
            .flatMap(p -> resolveIfValid(p, corpus))
            .flatMap(p -> resolveIfValid(p, filePath))
            .map(Path::toFile)
            .filter(File::canRead)
            // if the lookup above didn't work, try the defaults folder
            // see https://github.com/instituutnederlandsetaal/blacklab-frontend/pull/69
            .or(() -> dataDir
                .flatMap(p -> resolveIfValid(p, fallbackCorpus))
                .flatMap(p -> resolveIfValid(p, filePath))
                .map(Path::toFile)
                .filter(File::canRead)
            )
            // try default file inside .war
            // only available for a couple of standard items (search.xml, some builtin xslt files)
            .or(() -> {
                try {
                    URL url = MainServlet.class.getResource("/interface-default/" + filePath.get());
                    if (url == null) return Optional.empty();
                    URI uri = url.toURI();
                    return Optional.of(new File(uri)).filter(File::exists);
                } catch (URISyntaxException e) {
                    return Optional.empty();
                }
            });
    }

    /**
     * <pre>
     * Get the stylesheet to convert a document or its metadata from this corpus into
     * an html snippet suitable for inserting in the article.vm page.
     *
     * First attempts to find file "${name}_${corpusDataFormat}.xsl" in all locations, then,
     * as a fallback, attempts to find "${name}.xsl" in all locations.
     * The data format suffix is supported to allow placing xsl files for all corpora in the same fallback directory.
     * "meta.xsl" is conventionally used to transform the document's metadata, "article.xsl" for the content.
     * E.G.: "article_corpusDataFormat.xsl", so "article_tei" for tei, etc.
     * The regular "article.xsl" could be used as a global fallback.
     *
     * First tries retrieving the file using {@link #getProjectFile(String, Optional, Optional, Optional)}
     * If that fails, tries contacting BlackLab-server for an autogenerated best-effort xsl file.
     *  - Note that BlackLab only returns an xsl when the corpusDataFormat describes XML-based documents (i.e. not tsv, csv, plaintext, etc)
     * </pre>
     *
     * @param corpus - which corpus to load the file for.
     * @param fileName - the name of the file, excluding extension
     * @param request - the request, used to retrieve auth credentials for blacklab-server in case they're needed.
     * @param response - the response, used to return to the client when no credentials are available, and they're needed.
     * @param config - the global configuration, used to copy auth headers from the client request to the blacklab request.
     * @return the xsl transformer to use for transformation, note that this is always the same transformer.
     */
    public static Result<XslTransformer, TransformerException> getStylesheet(
            CorpusConfig corpus,
            GlobalConfig config,
            String fileName,
            HttpServletRequest request,
            HttpServletResponse response
    ) {
        Optional<String> fullFileName = corpus.getCorpusDataFormat().map(formatName -> fileName + "_" + formatName + ".xsl");
        Optional<String> fallbackFilename = Optional.of(fileName + ".xsl"); // e.g. article.xsl, meta.xsl
        String filesDir = config.get(Keys.CORPUS_CONFIG_DIR);
        Optional<String> fallbackDirectory = Optional.of(config.get(Keys.DEFAULT_CORPUS_CONFIG));

        // resolve file on disk
        Optional<File> file = getProjectFile(filesDir, Optional.of(corpus.getCorpusId()), fallbackDirectory, fullFileName)
                .or(() -> getProjectFile(filesDir, Optional.of(corpus.getCorpusId()), fallbackDirectory, fallbackFilename));

        // Dance around types, since the API uses Result<> but file resolving uses Optional<>
        Result<File, QueryException> fileResult = Result.from(file);
        Result<String, QueryException> blacklabResult = Result.empty();

        // TODO: bit of a hack.
        // The builtin "article.xsl" is now loaded if there is no dedicated article file for the corpus
        // Ignore it for now, and try to get the version from BlackLab
        if (fileName.equals("article") && fileResult.matches(f -> f.getPath().contains("interface-default"))) {
            // attemp to load the file from blacklab, only using the default article.xsl if blacklab return 404.
            // (if the blacklab file is invalid, raise that error, it should never happen, and we want to know about it)
            // This is a bit of a hack, but it works for now.
            logger.fine("Stylesheet: article - trying to load from blacklab");
            blacklabResult = new BlackLabApi(request, response, config)
                .getStylesheet(corpus.getCorpusDataFormat().get())
                .flatMapError(e -> e.getHttpStatusCode() == 404 ? Result.empty() : Result.error(e)); // if blacklab returns a 404, return empty instead of the http error.
                
        }

        return blacklabResult // attempt to use the BlackLab stylesheet first, as we only retrieve it when needed
            .tapSelf(r -> logger.fine("Stylesheet '"+fileName+"' from blacklab: " + (r.hasError() ? "error" : r.hasResult() ? "present" : "empty")))
            .mapWithErrorHandling(xsl -> new XslTransformer(corpus.getCorpusDataFormat().get(), xsl))
            .mapError(e -> new TransformerException("Error loading stylesheet from blacklab:\n" 
                + corpus.getCorpusDataFormat().get() + "\n"
                + e.getMessage() + "\n"
                + ExceptionUtils.getStackTrace(e))
            )
            .or(() -> fileResult
                .tapSelf(r -> logger.fine("Stylesheet '"+fileName+"' from disk: " + (r.hasError() ? "error! - " + r.getError().get(): r.hasResult() ? r.getResult().get() : "empty")))
                .mapWithErrorHandling(XslTransformer::new)
                .mapError(e -> new TransformerException("Error loading stylesheet from disk:\n"
                    + file.get() + "\n"
                    + e.getMessage() + "\n"
                    + ExceptionUtils.getStackTrace(e))
                )
            )
            .orError(() -> new TransformerException("File not found on disk, and no fallback available: " + fileName + ".xsl"));
    }

    private static Optional<Path> getIfValid(String path) {
        if (path == null || path.isEmpty())
            return Optional.empty();

        try {
            return Optional.of(Paths.get(path));
        } catch (InvalidPathException e) {
            return Optional.empty();
        }
    }

    /**
     * Resolve the child again the parent and verify that the child is indeed a descendant.
     * Also handle null, illegal paths, empty strings and other such things.
     *
     * @return the new path if everything is alright
     */
    private static Optional<Path> resolveIfValid(Path parent, Optional<String> child) {
        try {
            // prevent upward directory traversal - child must be in parent
            return child.map(parent::resolve).filter(resolved -> resolved.startsWith(parent) && !resolved.equals(parent));
        } catch (Exception e) { // catch anything, a bit lazy but allows passing in null and empty strings etc
            return Optional.empty();
        }
    }

    public static boolean isUserCorpus(Optional<String> corpus) {
        return getCorpusOwner(corpus).isPresent();
    }

    /** User corpora are identified by having a colon in their id separating username:corpusname */
    public static Optional<String> getCorpusName(Optional<String> corpus) {
        return corpus.map(id -> StringUtils.substringAfter(id, ":")).map(StringUtils::trimToNull).or(() -> corpus).map(StringUtils::capitalize);
    }

    /** User corpora are identified by having a colon in their id separating username:corpusname */
    public static Optional<String> getCorpusOwner(Optional<String> corpus) {
        return corpus.map(id -> {
            String[] parts = StringUtils.split(id, ":");
            return parts.length > 1 ? parts[0] : null;
        }).map(StringUtils::trimToNull);
    }
}
